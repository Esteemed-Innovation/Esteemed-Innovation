import java.nio.file.Files
import java.nio.file.Paths

buildscript {
    repositories {
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }

        maven {
            name = "sonatype"
            url = "https://oss.sonatype.org/content/repositories/snapshots/"
        }
        jcenter()
    }

    dependencies {
        classpath 'net.minecraftforge.gradle:ForgeGradle:2.2-SNAPSHOT'
        classpath 'org.ajoberstar:grgit:1.1.0'
        classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.7'
    }
}

apply plugin: 'net.minecraftforge.gradle.forge'
apply plugin: 'java'
apply plugin: 'com.jfrog.bintray'
apply plugin: 'maven-publish'

version = newModVersion + '-api' + newAPIVersion

/*
Usage: `gradle build -Palpha=<version>` where <version> is the next version (different from newModVersion because
that is updated when we are releasing an actual public update. Modifying that makes reading commit history much more
confusing). It increments the .alphaversion file's first line at the end, so it can be thought of as "the next alpha version".

Example: `gradle build -Palpha=1.0.0 -Pdev` => version # 1.0.0-alpha1-<commit>
*/
def incrementAlphaVersion(int currentValue) {
    def file = new File('.alphaversion')
    file.newWriter();
    file << "${currentValue + 1}"
}

def getAlphaVersion() {
    if (!Files.exists(Paths.get('.alphaversion'))) {
        new File('.alphaversion').createNewFile()
        incrementAlphaVersion(0)
    }
    new File('.alphaversion').withReader { return it.readLine() }
}

int alpha = getAlphaVersion().toInteger()

if (project.hasProperty('alpha')) {
    version = project.property('alpha') + "-alpha" + alpha
}

if (project.hasProperty('dev')) {
    def git = org.ajoberstar.grgit.Grgit.open(file('.'))
    project.version += '-' + git.head().getAbbreviatedId(6)
}

task finalize << {
    if (project.hasProperty('alpha')) {
        incrementAlphaVersion(alpha)
    }
}

build.finalizedBy(finalize)

group = "eiteam.esteemedinnovation"
archivesBaseName = "EsteemedInnovation-1.10"

sourceCompatibility = 1.8
targetCompatibility = 1.8

minecraft {
    version = project.forgeVersion
    mappings = project.mcpMappings
    runDir = "eclipse"
    replace "@VERSION@", newModVersion
    replace "@APIVERSION@", newAPIVersion
}

repositories {
    maven {
        name = "ic2"
        url = "http://maven.ic2.player.to/"
    }

    // Used for Mantle, Natura, Tinkers' Construct, and JEI.
    maven {
        name "progwml6"
        url "http://dvs1.progwml6.com/files/maven"
    }

    maven {
        name "tterrag Repo"
        url "http://maven.tterrag.com"
    }
    maven {
        name "ProfMobius"
        url "http://mobiusstrip.eu/maven"
    }

    maven {
        name = "The CB Project"
        url "http://chickenbones.net/maven"
    }
}

/*
Coherent list of mods that we added integration for which do not support 1.9 yet:
- Natura
- CoFH Core/Thermal Foundation
- Thaumcraft
- Twilight Forest
- Botania
- Railcraft
*/
dependencies {
    /*
    These are the mods that have not updated to 1.9 yet.
    compile naturaVersion
    */
//    There are some issues that I can't figure out with these mods.
//    compile mantleVersion
//    compile ticVersion
//    Using different mappings, cannot generate world. TODO: Resolve this.
//    compile ic2Version
    compile jeiVersion
    compile cclibVersion
    compile eioVersion
    compile ecoreVersion

    // Avoiding using the generic "lib".
    compile fileTree(dir: 'eilib', include: '*.jar')

    testCompile 'junit:junit:4.12'
}

processResources {
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
        filter {
            it.replaceAll('@VERSION@', project.version)
        }
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java', 'src/api/java']
        }
    }
}

task apiJar(type: Jar) {
    classifier = 'api'
    from sourceSets.api.allJava
}

artifacts {
    archives apiJar
}

publishing {
    publications {
        apiPublication(MavenPublication) {
            artifact apiJar
        }
    }
}

bintray {
    if (System.hasProperty('bintray_user') && System.hasProperty('bintray_key')) {
        user = bintray_user
        key = bintray_key
        publications = ['apiPublication'] 
        pkg {
            repo = 'Esteemed-Innovation'
            name = 'Releases'
            userOrg = 'esteemed-innovation'
            version {
                name = project.version
            }
        }
    }
}
